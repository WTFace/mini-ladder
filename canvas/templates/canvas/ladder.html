{% load static %}
<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link rel="stylesheet" type="text/css" href="{% static 'canvas/main.css' %}">

</head>
<body>
{% if res.REMOTE_ADDR in allowed %}
    <div id="container">
        <div id="result">result even odd</div>
    </div>
    <div class="progress-container">
        <progress id="bar" value="0" max="300000"></progress>
    </div>
    <div id="timer"></div>

<script>
    let bridge, bridge2, bridge3;
    let left_wall;
    let right_wall;
    let ball;
    const X = 70; const Y = 70;
    const radius = 20;
    const bridgeWidth = 150
    const current = new Date();
    let val = (current.getMinutes()%5)*60000;


    function startGame() {
        // for (var i = 1; i <= n; i++) {
        //     Things[i]
        // }
        bridge = new component(bridgeWidth, radius, "skyblue", X+radius, 120);
        bridge2 = new component(bridgeWidth, radius, "skyblue", X+radius, 170);
        ball = new component(radius, radius, "red", X, Y);
        bridge.update();
        bridge2.update();
        myGameArea.run();
    }

    let myGameArea = {
        canvas : document.createElement("canvas"),
        init: function(){
            this.canvas.width = 380;
            this.canvas.height = 360;
            this.context = this.canvas.getContext("2d");
            document.querySelector('#container').insertBefore(this.canvas, document.querySelector('#container').childNodes[0]);
            left_wall  = new component(radius, 225, "skyblue", X, Y);
            right_wall  = new component(radius, 225, "skyblue", X+radius+bridgeWidth, Y);
            left_wall.update();
            right_wall.update()
        },
        run : function() {
            this.interval = setInterval(updateGameArea, 15);
        },
        clear : function() {
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        },
        stop : function() {
            clearInterval(this.interval);
        }
    }

    function component(width, height, color, x, y) {
        this.width = width;
        this.height = height;
        this.speedX = 0;
        this.speedY = 1;    
        this.x = x;
        this.y = y;
        this.wasLeft = 0;
        if (x < 100) this.wasLeft = 1
        
        this.update = function() {
            ctx = myGameArea.context;
            ctx.fillStyle = color;
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.globalCompositeOperation='srouce-over';
        }
        this.crashRight = function(otherobj) {
            let myleft = this.x;
            let otherleft = otherobj.x;
            let crash = true;
            if (myleft < otherleft) {
                crash = false;
            }
            return crash
        }
        this.crashLeft = function(otherobj) {
            let myleft = this.x;
            let otherleft = otherobj.x;
            let crash = true;
            if (myleft > otherleft) {
                crash = false;
            }
            return crash
        }
        this.crashBot = function(otherobj) {
            let mytop = this.y;
            let othertop = otherobj.y;
            let crash = true;
            if (mytop !== othertop) {
                crash = false;
            }
            return crash
        }

    }

    function updateGameArea() {
        if ((ball.crashRight(right_wall) && ball.wasLeft===1) || (ball.crashLeft(left_wall)) && ball.wasLeft===0) {
            if(ball.speedX !==0 ) ball.y += 1
            if (ball.x>200) {
                ball.wasLeft = 0
            }else{
                ball.wasLeft = 1
            }
            ball.speedY = 1
            ball.speedX = 0
        }
        
        if ((ball.crashBot(bridge)|| ball.crashBot(bridge2)) && ball.speedY===1) {
            ball.speedY = 0
            if (ball.x>200) {
                ball.speedX = -1
            }else{
                ball.speedX = 1
            }
            console.log(ball.x, ball.speedX, ball.wasLeft)
        }
        if (ball.y > left_wall.y + left_wall.height-ball.height) myGameArea.stop()
        // myGameArea.clear();
        ball.update();
        ball.x += ball.speedX;
        ball.y += ball.speedY;    
    }

    // let myVar = setInterval(refreshGame, 1000);

    // function refreshGame() {
    //   let d = new Date();
    //   document.getElementById("timer").innerHTML = d.toLocaleTimeString() + ' (5분마다 시작)';
    //   val += 1000
    //   document.querySelector("progress").value = val
    //   if (d.getMinutes()%5===0 && d.getSeconds()===0) {
    //     val = 0
    //     startGame()
    //   }
    // }
    myGameArea.init();
    startGame()
</script>
{% else %}
    {{res.REMOTE_ADDR}}
{% endif %}
</body>
</html>